# php3 lesson3

Продолжаем мучить laravel:
1. У нас, с прошлого домашего задания, уже есть модель пользователя - класс app\User. 
Создадим новый метод getName, но прежде "подредактируем" нашу таблицу users в бд. У нас есть поле name, заменим его на поля
firstName, lastName, c. Итак:
```bash
php artisan make:migration alter_table_users
``` 
Создалась миграция 2018_01_03_095715_alter_table_users
Заполняем класс миграции. Важный нюанс, в таблице уже могут быть данные (в общем то они и есть), вновь создаваемые поля не должны быть not_null либо должно быть задано дефолтное значение.
Поскольку мы добалвем тип string - (varchar), я лично предпочитаю задавать дефолтное значение - пустая строка, вместо nullable. Вопрос очень дискуссионный, может я и не совсем прав, наверное отдельные товарищи меня бы заклевали за это. Но не суть. Применяем нашу миграцию:
```bash
php artisan migrate
```
Все, наша таблица готова. Кроме того, мы должны поправить данные в защищеном свойстве класса User fillable, чтобы мы могли вставлять значения в таблицу используя массовое присвоение. Удалим из массива значение 'name' и добавим firstName', 'lastName', 'patronymic'.

2. Тестирование. В начальную сборку Laravel уже включен фреймворк PHPUnit. В нашем случае это версия 6.0. Следует отметить, что в Laravel PHPUnit уже предварительно сконфигурирован. Файл phpunit.xml находится в корне проекта. При запуске тестов программа будет искать классы тестов в директориях tests/Unit и tests/Feature. Нас такое поведение не очень устраивает, подредактрием файл phpunit.xml добавив еще поиск в директории /tests. Кроме того, в artisan специально добавлены команды для запуска тестов (но мы будем использовать команды phpunit). Чтобы мы могли запускать тесты в Unix подобной системе (у меня MacOs) воспользуемся иструкцией https://github.com/sebastianbergmann/phpunit. Скачиваем файл phpunit.phar, затем в консоли набираем:

```bash
cd ~/Downloads

chmod +x phpunit-6.5.5.phar

mv phpunit-6.5.5.phar /usr/local/bin/phpunit
```
Все, теперь мы можем запускать наши тесты, набрав в корне приложения команду phpunit.

Создаем класс проверки нашей функции (метода класса User). Дадим ему имя UserTest. Внутри класса  будем использовать трейт DatabaseTransactions. Все наши данные, добавленные в базу в ходе теста будут откачены после завершения теста.
Собственно что касается самих тестов, признаюсь фантазии у меня не много. Просто переберем все возможные варианты, которые могут вернуть функция getName() и сравним при помощи метода assertEquals что наша функция возвращает именно то, что от нее ждем. У меня получилось 6 методов.

3. Запускаем наши тесты. Из корневой папки проекта запускаем команду phpunit. Видим что 8 тестов из 8 (2 ларавелевских и 6 наших зеленые).

4. Добавляем запуск тестов в задание в phing - файл build.xml. Команда phpunit должна запускаться уже после применения миграций, но до создания символической ссылки на проект. Кроме того, до запуска тестирования нам необходимо закинуть на сервер файл phpunit.phar, поскольку нет никакой гарантии, что команда phpunit сработает на сервере.
Договоримся, что файл phpunit.phar последеней версии будет лежать в папке build. На всякий случай напомню схему сборки нашего проекта. Папка куда собираются сборки называется assembly, где создается символическая ссылка public_html, а файл базы данных (sqlite3) с именем php3.sqlite лежит в папке database.
Все три директории расположены на уровень выше корня нашего проекта. Это все должно быть создано до начала запуска команды сборки. Итак запускаем команду сборки:

```bash
php build/phing.phar -f build/build.xml
```
Видим, что сразу после применения миграций запустились тесты. Попробуем испортить нашу функцию getName, и снова запустим процесс сборки. Как видим, тест провалился. Таким образом, сборка прервалась уже на этом этапе, до создания символической ссылки дело не дошло. Таким образом, сборка с проваленным тестом на production не попала, что в общем то и требовалось.

5. 