1. Для начала создадим консольную команду, назовем ее CheckMemory. В laravel консольная команда создается другой консольной командой - php artisan make:command ИмяКоманды. Итак, создаем:

```bash
php artisan make:command CheckMemory
```

После этого в папке app/Console создалась директория Commands и в ней появился наш класс CheckMemory. В этом классе есть два защищенных свойства signature и description (т.е. как выглядит сама команда и ее описание соответственно) а также метод handle() который будет вызван при запуске команды. При этом свойству signature мы можем задать не только название, но и передать какой-то аргумент (в фгурных скобках через пробел после команды). Количество аргументов может быть любым. Разновидностью аргумента является опция, записывается также в фигурных скобках, но с двоиным дефисом перед названием. Кроме того, через конструктор класса мы можем внедрять нужные нам зависимости.

Присваиваем свойства и пишем реализацию для метода. Наша команда будет называться memory:check После регистрируем нашу консольную команду. Регистрация происходит в классе App\Console\Kernel в защищенном свойстве commands, который первоначально имеет значение пустой массив. Именно в этот массив нужно добавить наш класс. Что мы и делаем - CheckMemory::class.
Измерения буду проводить на версии php 7.2.1. Информация об измерениях будет записываться в лог - файл storage/logs/checkmem.log. Для логирования будем использовать штатное средство laravel  класс Monolog\Logger. При вызове консольной команды будем передавать значения для двух аргументов 1-е это число элементов в массиве, второе - булево значение, то что будет передаваться в функцию memory_get_usage.
Задача стоит замерить количество потребляемой памяти. Призаюсь честно, мне не до конца понятно, что понимается под этой формулировкой. С одной точки зрения, количество используемой скрипом памяти и должно быть количеством потребляемой памяти. С другой, само название передаваемого в функцию memory_get_usage аргумента real_usage говорит, что более правильная цифра - это количество выделенной скрипту пямяти. Какая разница сколько процесс потребил? Важно сколько было выделено. Выделено, значит израсходовано, т.е. эта память уже отдана и в другом процессе ее задействоать уже нельзя.
Попробуем вызвать консольную команду два раза, один раз со значением во второй аргумент - true, а затем false, потом сравним, что позволит сделать более объемные выводы. 
В первом случае консольная команда будет выглядеть следующим образом:

```bash
php artisan memory:check 1000000 1
```

Лог выдал нам вот такую информацию:

```log
[2018-01-08 16:14:50] Checking Memory.INFO: report ["total memory on 1 million items 33558528 bytes",
                                                    "result of one integer set is 33.558528bytes",
                                                    "before 10485760 bytes",
                                                    "after 44044288 bytes"] []
```

А если:
```bash
php artisan memory:check 1000000 0
```
то:
```log
[2018-01-08 16:12:07] Checking Memory.INFO: report ["total memory on 1 million items 33558608 bytes",
                                                    "result of one integer set is 33.558608bytes",
                                                    "before 9120944 bytes",
                                                    "after 42679552 bytes"] []
```
И что мы видим? На создание массива в 1 млн. записей было выделено 33558528 байт. А требуется ему 33558608. Даже больше, чем было выделено. Это действительно неожиднанно.
Выходит, что недостаток выделенной памяти скрипт взял из того, что было ранее выделено, из тех 10485760 байт (из которых востребовано было только 9120944 байт).
Но нужно отметить, что разница между первой и второй цифрой незначительна, наверное для нашего расчета можно использовать любое из них. Но все же для большей точности будем использовать значение полученное при использовании false в качестве значения аргумента для memory_get_usage.
Делим количество поторебленной скриптом памяти 33558608 байт на 1 млн (количество элементов типа int в массиве) и получаем 33.558608. Действительно, даже при округлении этого значения до тысячных мы бы не увидили разницу, по сравнению с первым расчетом.
2. Минимальная версия php с которой "согласился" работать laravel это 7.0. Поэтому протестировать работу более ранних версиях не получится. Надо было выбирать Yii.

3. Пока не понял как можно решить это задание опытным путем.

4. Создадим класс App\SomeClass с публичными свойствами self и value. Для выполнения задания создадим еще одну консольную команду, назовем ее chasing:cycle а функция для этой команды СhasingTheCycle - 'гоняем цикл'. Не уверен в правильности перевода.
Зададим условия, как указано в задании. В консольную команду нужно передать два аргумента 1 - количество итераций в цикле, 2. число итераций, через которое нужно делать замер. Даем команду:
```bash
php artisan chasing:cycle 1000000 500
```
Скрипт работал меньше секунды, в итоге в файл лога было записано 2000 строк - именно столько замеров было сделано. Однако, значение везде одинаковы - 9301096 байт, за исключением значения на первом замере, там эта цифра несколько ниже 9240168 байт. Если мы сделаем замер еще до цикла, то получим то же самое значение 9240168 на первой итерации и 9300912. Таким образом, видим что сам замер несет определенные накладные расходы, что при первом замере не учитывается.
В целом поведение скрипта объяснимо, ведь на каждой итерации мы всего лишь создаем объект и присваиваем ему значение, но при этом не сохраняем его никуда (в массив например). Пожтому на каждой итерации наша память освобождается а затем заполняется снова. Вот если мы начнем созданный на каждой итерации объект в массив, то на каждом замере количество будет планомерно возрастать, что тоже предсказуемо (и я это тоже попробовал сделать, но задача у нас другая). Операция по привоению значения свойству объекта почти бесплатна. Если мы уберем эту операцию из скрипта, то потребление уменьшится всего на 24 байта. Даже комментарий стоит дороже.