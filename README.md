# php3 lesson3

Продолжаем мучить laravel:
1. У нас, с прошлого домашего задания, уже есть модель пользователя - класс app\User. 
Создадим новый метод getName, но прежде "подредактируем" нашу таблицу users в бд. У нас есть поле name, заменим его на поля
firstName, lastName, c. Итак:
```bash
php artisan make:migration alter_table_users
``` 
Создалась миграция 2018_01_03_095715_alter_table_users
Заполняем класс миграции. Важный нюанс, в таблице уже могут быть данные (в общем то они и есть), вновь создаваемые поля не должны быть not_null либо должно быть задано дефолтное значение.
Поскольку мы добалвем тип string - (varchar), я лично предпочитаю задавать дефолтное значение - пустая строка, вместо nullable. Вопрос очень дискуссионный, может я и не совсем прав, наверное отдельные товарищи меня бы заклевали за это. Но не суть. Применяем нашу миграцию:
```bash
php artisan migrate
```
Все, наша таблица готова. Кроме того, мы должны поправить данные в защищеном свойстве класса User fillable, чтобы мы могли вставлять значения в таблицу используя массовое присвоение. Удалим из массива значение 'name' и добавим firstName', 'lastName', 'patronymic'.

2. Тестирование. В начальную сборку Laravel уже включен фреймворк PHPUnit. В нашем случае это версия 6.0. Следует отметить, что в Laravel PHPUnit уже предварительно сконфигурирован. Файл phpunit.xml находится в корне проекта. При запуске тестов программа будет искать классы тестов в директориях tests/Unit и tests/Feature. Нас такое поведение не очень устраивает, подредактрием файл phpunit.xml добавив еще поиск в директории /tests. Кроме того, в artisan специально добавлены команды для запуска тестов (но мы будем использовать команды phpunit). Чтобы мы могли запускать тесты в Unix подобной системе (у меня MacOs) воспользуемся иструкцией https://github.com/sebastianbergmann/phpunit. Скачиваем файл phpunit.phar, затем в консоли набираем:

```bash
cd ~/Downloads

chmod +x phpunit-6.5.5.phar

mv phpunit-6.5.5.phar /usr/local/bin/phpunit
```
Все, теперь мы можем запускать наши тесты, набрав в корне приложения команду phpunit.

Создаем класс проверки нашей функции (метода класса User). Дадим ему имя UserTest. Внутри класса  будем использовать трейт DatabaseTransactions. Все наши данные, добавленные в базу в ходе теста будут откачены после завершения теста.
Собственно что касается самих тестов, признаюсь фантазии у меня не много. Просто переберем все возможные варианты, которые могут вернуть функция getName() и сравним при помощи метода assertEquals что наша функция возвращает именно то, что от нее ждем. У меня получилось 6 методов.

3. Запускаем наши тесты. Из корневой папки проекта запускаем команду phpunit. Видим что 8 тестов из 8 (2 ларавелевских и 6 наших зеленые).

4. Добавляем запуск тестов в задание в phing - файл build.xml. Команда phpunit должна запускаться уже после применения миграций, но до создания символической ссылки на проект. Кроме того, до запуска тестирования нам необходимо закинуть на сервер файл phpunit.phar, поскольку нет никакой гарантии, что команда phpunit сработает на сервере.
Договоримся, что файл phpunit.phar последеней версии будет лежать в папке build. На всякий случай напомню схему сборки нашего проекта. Папка куда собираются сборки называется assembly, где создается символическая ссылка public_html, а файл базы данных (sqlite3) с именем php3.sqlite лежит в папке database.
Все три директории расположены на уровень выше корня нашего проекта. Это все должно быть создано до начала запуска команды сборки. Итак запускаем команду сборки:

```bash
php build/phing.phar -f build/build.xml
```
Видим, что сразу после применения миграций запустились тесты. Попробуем испортить нашу функцию getName, и снова запустим процесс сборки. Как видим, тест провалился. Таким образом, сборка прервалась уже на этом этапе, до создания символической ссылки дело не дошло. Таким образом, сборка с проваленным тестом на production не попала, что в общем то и требовалось.

5. Для начала проведем некоторую подготовительную работу. Во первых, нужно определить, где у нас будет собираться статистика посещений. Создадим таблицу visiting:

```bash
php artisan migrate create_visits_table
``` 

Не будем усложнять, по сути наша таблица готова в ней есть автоинкремент и поля created_at и updated_at. Пожалуй сюда можно добавить поле булева типа 'notificate' т.е. отправлялось ли данное сообщение по этому посещению или нет. Понимаю очень упрощенно.
Далее настроим отправку почты. В ларавел уже все для этого есть. Итак даем команду:
```bash
php artisan make:mail MailClass
``` 
Создался класс App\Mail\MailClass. В нем 2 метода - конструктор и метод build. Последний формирует сообщение, кладет данные в нужный шаблон и т.д. Сразу же создадим шаблон нашего сообщения. Файл resources/views/mails/contact-mail.blade.php.

Логика работы будет тоже очень примитивной. Статистика посещений будет у нас наполняться при входе на любую страницу сайта. Мне кажется, что счетчик логичнее всего поместить в файл layout.
Хоть у нас в начальном варианте ларавел только одна страница, я немного здесь отрефакторил. Создал файл layout'а это файл resources/views/layouts/main.balde.php. А уже шаблон нашей единственной страницы resources/views/welcome.blade.php будет наследовать слой.
Ну собственно скрипт, отвечающий за вызов счетчика будет помещен внизу страницы. Шаблонизатор blade предоставляет нам некий синтаксический сахар, позволяя заключать php скрипт между тегами @php @endphp 
Сам скрипт будет очень примитивным, но мы все равно организуем его в некую бизнес логику, чтобы не происходило работы напрямую с моделью из view. Создадим в папке app директорию Counters и создадим там наш класс VisitCounter. Создадим в этом классе метод fixVisit который просто берет и создает новую запись в таблице visits.
В этом же классе будут все остальные методы, нужные нам для этого задания. Мне бы хотелось воспользоваться магией laravel и "засунуть" этот класс в сервис провайдер, так чтобы потом вызывать фасад и обращаться к динамическим методам "как к статическим".
Для этого создам фасад  App\Core\Facades\VisitCounter, зарегистрируем этот фасад во вновь созданном сервис-провадере App\Providers\CounterServiceProvider. Ну и добавим информацию об этом в конфиг - файл config/app.php. В секцию провайдеры добавим наш провайдер, а в секцию алиасов наш фасад, с тем же названием алиаса VisitCounter (чтобы никто не догадался).

